# B+树文档

## 背景
B+树是一种多路平衡搜索树，是数据库系统和文件系统中常用的索引结构。它特别适合用于磁盘存储系统，因为：

- 保持数据有序
- 允许高效查找、顺序访问、插入和删除
- 保持平衡，确保操作时间复杂度稳定

## 核心特征
### 多层级结构
- **内部节点**（索引节点）：存储键和子节点指针
- **叶子节点**：存储键和实际数据(或数据指针)

### 关键特性
- 节点容量：每个节点最多包含`m-1`个键和`m`个子节点/指针
- 平衡性：所有叶子节点位于同一层级
- 链表连接：叶子节点通过指针相互连接，支持高效范围查询

## 节点结构
### 内部节点
| 属性       | 说明                          |
|------------|-----------------------------|
| 键存储     | 用于路由查找路径              |
| 指针数量   | 键数量+1 (m个子节点)          |

### 叶子节点
| 属性       | 说明                          |
|------------|-----------------------------|
| 数据存储   | 包含键值对或数据指针          |
| 链表指针   | 通过`next`连接下一个叶子节点  |

## 关键公式
### 节点填充率（阶数为m）
| 节点类型   | 最小数量              | 最大数量     |
|------------|---------------------|------------|
| 内部节点   | ⌈m/2⌉-1键, ⌈m/2⌉子节点 | m-1键, m子节点 |
| 叶子节点   | ⌈m/2⌉-1键值对         | m-1键值对    |

### 树的高度
对于包含`n`个键的B+树，高度`h`满足：
h ≤ log⌈m/2⌉((n+1)/2) + 1


## 实现关键点
### 分裂操作
    A[节点溢出] --> B[叶子节点分裂]
    A --> C[内部节点分裂]
    B --> D[中间键提升到父节点]
    C --> D

### 合并操作
- **触发条件**：当节点低于最小容量时触发
- **处理流程**：
  1. 尝试从兄弟节点借元素
  2. 无法借用则与兄弟节点合并

### 查找路径

根节点 → 根据键值比较选择路径 → 叶子节点

## 应用案例

| 领域          | 应用场景         | 优势                          |
|---------------|------------------|-------------------------------|
| 数据库索引    | MySQL InnoDB     | 高效点查询和范围查询          |
| 文件系统      | NTFS, ReiserFS   | 高效元数据组织                |
| 内存数据库    | Redis模块        | 有序性和范围查询优势          |
| 时间序列数据  | 时序数据库       | 高效时间范围查询              |

## 快速使用示例

```go
// 创建B+树（阶数=4）
tree := NewBPTree[int, string](4, func(a, b int) int {
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
})

// 基本操作
tree.Insert(5, "five")          // 插入
value, found := tree.Find(5)    // 查找
results := tree.RangeQuery(3,6) // 范围查询
deleted := tree.Delete(3)       // 删除
```

## 性能分析
| 操作       | 时间复杂度       | 备注                              |
|------------|------------------|-----------------------------------|
| 查找       | O(logₘn)         | m为阶数，n为元素数量               |
| 插入       | O(logₘn)         | 可能需要分裂节点                   |
| 删除       | O(logₘn)         | 可能需要合并或借用节点             |
| 范围查询   | O(logₘn + k)     | k为范围内元素数量                  |

## 进阶优化方向
并发控制：添加读写锁支持

持久化支持：实现磁盘存储格式

批量加载：优化初始数据加载

节点压缩：提高空间利用率

缓存优化：匹配CPU缓存行大小