黑名单场景，数量大于100,000才管用。
base：
提供：
   动态布隆过滤器：自动扩容（如 redisbloom 的实现）。

分层存储：热数据用 map，冷数据用布隆过滤器。

Cuckoo Filter：需要支持删除时，可替换布隆过滤器。

## 背景

## 实现思路

布隆过滤器(Bloom Filter)是一种空间效率高的概率型数据结构，用于判断一个元素是否在集合中。它的核心思想是：

1. **位数组表示集合**：使用一个长度为m的位数组(bit array)作为底层存储
2. **多个哈希函数**：使用k个不同的哈希函数，每个函数可以将元素映射到位数组的某个位置
3. **添加元素**：将元素通过所有k个哈希函数映射到位数组，并将对应位置设为1
4. **查询元素**：检查元素通过所有k个哈希函数映射的位置是否都为1
   - 如果所有位置都为1 → 元素"可能存在"(可能有假阳性)
   - 如果有任一位置为0 → 元素"绝对不存在"(不会有假阴性)

## 关键公式

### 1. 最优位数组大小(m)

对于预期元素数量n和期望的假阳性概率p，最优的位数组大小m计算公式为：

```
m = - (n * ln(p)) / (ln(2)^2)
```

推导过程：
- 假设哈希函数是完全随机的
- 一个特定bit在插入一个元素后仍为0的概率是 (1 - 1/m)^k
- 插入n个元素后仍为0的概率是 (1 - 1/m)^(k*n) ≈ e^(-k*n/m)
- 假阳性概率p ≈ (1 - e^(-k*n/m))^k

通过求导可以得到最优的k和m

### 2. 最优哈希函数数量(k)

最优的哈希函数数量k计算公式为：

```
k = (m/n) * ln(2)
```

这个值可以最小化假阳性概率

### 3. 实际假阳性概率

在实际使用中，假阳性概率的近似值为：

```
p ≈ (1 - e^(-k*n/m))^k
```

## 实现关键点

1. **哈希函数选择**：
   - 需要独立且均匀分布的哈希函数
   - 实践中可以使用一个基础哈希函数加上不同的种子来模拟多个哈希函数
   - 示例中使用了FNV哈希算法

2. **空间与准确性的权衡**：
   - 位数组越大，假阳性概率越低，但占用内存越多
   - 哈希函数越多，准确性越高，但计算成本增加

3. **不支持删除操作**：
   - 标准布隆过滤器不支持删除，因为简单的置0会影响其他元素
   - 如果需要删除功能，可以考虑变种如Counting Bloom Filter

## 数学推导简版

1. 假设我们有m位的数组和k个哈希函数
2. 插入一个元素后，某一位仍然是0的概率：1 - 1/m
3. 插入n个元素后，某一位仍然是0的概率：(1 - 1/m)^(k*n) ≈ e^(-k*n/m)
4. 假阳性概率(所有k位都被设置为1)：(1 - e^(-k*n/m))^k
5. 对p = (1 - e^(-k*n/m))^k求极值，可以得到最优的k = (m/n)*ln(2)

这种数据结构特别适合在大规模数据集中进行快速成员查询，且可以容忍一定的误报率的场景，如URL黑名单检查、缓存穿透防护等。

## 关键学习点

### Hash包

### Go语言中的FNV-1a哈希算法：New64a函数详解

### bloom原理

### 应用案例

### 快速教程